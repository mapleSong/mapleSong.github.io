<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Gulp自动化构建工具]]></title>
      <url>/2017/06/07/gulp%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>Gulp.js 是基于 Node.js 构建的,利用 Node.js 流的威力,可以快速构建项目。</p>
<h2 id="Gulp介绍"><a href="#Gulp介绍" class="headerlink" title="Gulp介绍"></a>Gulp介绍</h2><p>​    Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。</p>
<h2 id="Gulp安装"><a href="#Gulp安装" class="headerlink" title="Gulp安装"></a>Gulp安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo npm install -g gulp   <span class="comment">// 全局安装gulp</span></div><div class="line">$ gulp -v 				     <span class="comment">// 查看gulp版本号，是否安装成功</span></div><div class="line">$ npm init 				     <span class="comment">// 创建文件夹，初始化npm(项目名称不能为gulp)</span></div><div class="line">$ npm install gulp —save-dev <span class="comment">// 当前文件夹安装本地gulp文件</span></div></pre></td></tr></table></figure>
<p>​    上述命令执行完成后需要再创建一个gulpfile.js文件来用来配置gulp。</p>
<h2 id="Gulp使用"><a href="#Gulp使用" class="headerlink" title="Gulp使用"></a>Gulp使用</h2><p>​    我使用gulp最常用的功能就是压缩css,js代码和添加css代码中兼容浏览器前缀。这三个功能分别需要安装三个gulp插件：gulp-uglify（压缩js代码）、gulp-css（压缩css代码）、gulp-autoprefixer（css兼容浏览器前缀）。所以需要通过npm来安装这三个插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$npm install gulp-uglify --save-dev</div><div class="line">$npm install gulp-css --save-dev</div><div class="line">$npm install gulp-autoprefixer --save-dev</div></pre></td></tr></table></figure>
<p>​    在项目中我们需要存放我们需要压缩的代码，在项目中创建一个src文件夹，其中存放js，css文件。</p>
<p>​    |——src</p>
<p>​        |——-js</p>
<p>​             ——main.js</p>
<p>​         |——-css</p>
<p>​          ——main.css</p>
<p>​      同理我们还需要创建一个压缩代码后存放文件的文件夹。</p>
<p>​      |——–dist</p>
<p>​        |—— js</p>
<p>​        |——-css</p>
<p>​    下面就要配置gulp文件了，在刚刚创建的gulpfile.js文件中进行配置。所有配置代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"><span class="keyword">var</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>);</div><div class="line"><span class="keyword">var</span> cssMin = <span class="built_in">require</span>(<span class="string">'gulp-css'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'script'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 压缩js代码</span></div><div class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'src/js/**/*.js'</span>)</div><div class="line">    .pipe(uglify()) <span class="comment">//引用插件</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'./dist/js'</span>)); <span class="comment">//存放的位置</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">gulp.task(<span class="string">'css'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'src/css/**/*.css'</span>)</div><div class="line">    .pipe(autoprefixer(&#123;  <span class="comment">//兼容性浏览器前缀添加</span></div><div class="line">        browsers:[<span class="string">'last 40 versions'</span>],<span class="comment">//版本范围</span></div><div class="line">        cascade:<span class="literal">false</span> <span class="comment">//是否美化属性值 默认是true 这里写false不需要</span></div><div class="line">    &#125;))</div><div class="line">    .pipe(cssMin()) <span class="comment">//引用插件</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));<span class="comment">//存放的位置</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'script'</span>,<span class="string">'css'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'任务完成'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//如果不需要兼容性前缀添加，直接将pipe(autoprefixer)任务这部分删除。其他同理。</span></div></pre></td></tr></table></figure>
<p>​    配置好gulp后就可以将代码存放在src中，通过命令来进行相应操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gulp <span class="comment">//默认全部执行</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gulp script <span class="comment">//仅压缩js代码</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gulp css <span class="comment">//仅压缩css代码</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 构建工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> gulp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript面向对象]]></title>
      <url>/2017/06/06/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h1><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><p>​    创建一个实例，为它添加属性和方法，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </div><div class="line">person.name = <span class="string">"Nicholas"</span>; </div><div class="line">person.age = <span class="number">29</span>; </div><div class="line">person.job = <span class="string">"Software Engineer"</span>;</div><div class="line"></div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name); </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​    上面的例子中名为person就是一个对象，其中有三个属性name、age、job和一个方法sayName()。</p>
<h1 id="设计原型"><a href="#设计原型" class="headerlink" title="设计原型"></a>设计原型</h1><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </div><div class="line">Person.prototype.age = <span class="number">29</span>; </div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name); </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </div><div class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//"Nicholas" </span></div><div class="line">alert(person1.sayName == person2.sayName);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>​    无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。</p>
<p>​    创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 <strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>
<p>​    以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，下图展示了各个对 象之间的关系。</p>
<p><img src="http://or2e12z3i.bkt.clouddn.com/screenshot2.png" alt=""></p>
<h4 id="更简单、实用的原型语法"><a href="#更简单、实用的原型语法" class="headerlink" title="更简单、实用的原型语法"></a>更简单、实用的原型语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="keyword">constructor</span>:Person, //指向所在函数指针</div><div class="line">  name : "Nicholas", </div><div class="line">  age : 29, job: "Software Engineer", </div><div class="line">  sayName : function () &#123;</div><div class="line">	alert(<span class="keyword">this</span>.name); </div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(friend.constructor == Person); <span class="comment">//true</span></div><div class="line">alert(friend.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript，前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git使用]]></title>
      <url>/2017/06/05/Git%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="Git的正确打开方式"><a href="#Git的正确打开方式" class="headerlink" title="Git的正确打开方式"></a>Git的正确打开方式</h1><h4 id="Git三个状态"><a href="#Git三个状态" class="headerlink" title="Git三个状态"></a>Git三个状态</h4><p>在Git中存在三个状态：工作区、暂存区、版本状态仓库。</p>
<p>工作区：工作区是我们在本地我们可以看得到的那一部分内容。例如在本地创建的文件夹里的文件，如果修改了文件中的内容可以通过 git status来查看是否文件有修改。</p>
<p>暂存区：当我们想要上传代码到git中首先要将工作区中的文件通过命令上传至git中的暂存区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .   //add后面的.是将所有未最终的文件添加在缓存区中。.也可以使用-A代替，实现效果一样。</div></pre></td></tr></table></figure>
<p>版本管理仓库：当我们的代码上传到指定服务器中后也，git版本状态中会自动存留一条此次上传文件的版本状态。通过命令可查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log</div></pre></td></tr></table></figure>
<p><img src="http://or2e12z3i.bkt.clouddn.com/screenshot.png" alt=""></p>
<p>其中commit是版本识别标识，我们可以通过commit码来回滚到指定版本，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard 80919da****    //commit码只需要输入前几位即可 git会自动识别</div></pre></td></tr></table></figure>
<h4 id="通过Git将文件提交至Github"><a href="#通过Git将文件提交至Github" class="headerlink" title="通过Git将文件提交至Github"></a>通过Git将文件提交至Github</h4><p>如果文件是第一次提交至github需要将需要上传的文件通过命令git初始化，命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure>
<p>工作区提交到暂存区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure>
<p>将本次提交生成一个标识来帮助我们查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit -m”someText”</div></pre></td></tr></table></figure>
<p>与github建立连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com：yourName / songProject.git </div><div class="line">//可在github创建一个库复制其git地址</div></pre></td></tr></table></figure>
<p>提交文件至github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<h4 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h4><p>更新文件基本与以上操作基本相似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add.</div><div class="line">$ git commit -m&quot;someText&quot;</div><div class="line">$ git push</div></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果是第一次使用git需要设置用户信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.name &quot;username&quot;</div><div class="line">$ git config user.email &quot;user@email.com&quot;</div></pre></td></tr></table></figure>
<p>查看是否设置成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config user.name </div><div class="line">$ git config user.email</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript闭包]]></title>
      <url>/2017/04/12/JavaScript%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包算是JavaScript经常会碰到的问题。简单的说就是函数嵌套关系到作用域链的问题。</p>
<p>学习了一下阮一峰的闭包讲解，概括起来就是变量作用域，全局和局部变量的判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n); </div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</div><div class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</div><div class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　alert(n);</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">return</span> f2;</div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> result=f1();</div><div class="line">　　result(); <span class="comment">// 999</span></div><div class="line">　　nAdd();</div><div class="line">　　result(); <span class="comment">// 1000</span></div></pre></td></tr></table></figure>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。所以在闭包中内存中会一直保存着局部变量。会占用内存，内存消耗大，对整体性能有影响。</p>
<p><strong>eg：</strong>绑定每个<code>span</code>的<code>click</code>事件，让鼠标点击span的时候alert出对应的index    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spans = $(<span class="string">"#divTest span"</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; spans.length; i++) &#123;</div><div class="line">      spans[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       alert(i);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>很简单的功能可是却偏偏出错了，每次alert出的值都是4，所以然者何？</p>
<p>上面代码在页面加载后就会执行，当i的值为4的时候，判断条件不成立，for循环执行完毕，但是因为每个span的onclick方法这时候为内部函数，所以i被闭包引用，内存不能被销毁，i的值会一直保持4，直到程序改变它或者所有的onclick函数销毁（主动把函数赋为null或者页面卸载）时才会被回收。</p>
<p>这样每次我们点击span的时候，onclick函数会查找i的值（作用域链是引用方式），一查等于4，然后就alert给我们了。而第二种方式是使用了一个立即执行的函数又创建了一层闭包，函数声明放在括号内就变成了表达式，后面再加上括号就是调用了，这时候把i当参数传入，函数立即执行，num保存每次i的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spans2 = $(<span class="string">"#divTest2 span"</span>);</div><div class="line">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; spans2.length; i++) &#123;</div><div class="line">            (<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">                spans2[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                    alert(num);</div><div class="line">                &#125;</div><div class="line">            &#125;)(i);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h2 id="逃脱"><a href="#逃脱" class="headerlink" title="逃脱"></a>逃脱</h2><p>JavaScript允许像传递任何类型的数据一样传递函数，也就是说JavaScript中的内部函数能够逃脱定义他们的外部函数。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalVar;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Outer function"</span>);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Inner function"</span>);</div><div class="line">    &#125;</div><div class="line">    globalVar = innerFn;</div><div class="line">&#125;</div><div class="line">outerFn();</div><div class="line">globalVar();</div></pre></td></tr></table></figure>
<p>调用outerFn时会修改全局变量globalVar，这时候它的引用变为innerFn，此后调用globalVar和调用innerFn一样。这时在outerFn外部直接调用innerFn仍然会导致错误，这是因为内部函数虽然通过把引用保存在全局变量中实现了逃脱，但这个函数的名字依然只存在于outerFn的作用域中。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>可以通过在父函数的返回值来获得内部函数引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Outer function"</span>);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Inner function"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> innerFn;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fnRef = outerFn();</div><div class="line">fnRef();</div></pre></td></tr></table></figure>
<p>这里并没有在outerFn内部修改全局变量，而是从outerFn中返回了一个对innerFn的引用。通过调用outerFn能够获得这个引用，而且这个引用可以可以保存在变量中。</p>
<h2 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h2><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包有三个特性：</p>
<blockquote>
<p>1.函数嵌套函数</p>
<p>2.函数内部可以引用外部的参数和变量</p>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
