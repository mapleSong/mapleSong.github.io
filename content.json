{"meta":{"title":"Asimov's Blog","subtitle":"Try to find me.","description":"Try to find me.","author":"Asimov","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"2017年终总结","slug":"2017年终总结","date":"2018-02-15T11:00:10.000Z","updated":"2018-02-15T15:17:48.000Z","comments":true,"path":"2018/02/15/2017年终总结/","link":"","permalink":"http://yoursite.com/2018/02/15/2017年终总结/","excerpt":"","text":"​ 年末断断续续也写了一些但还是太细碎了，趁着离过年还有一段时间还是要把总结完整的写一写。 ​ 第一次写总结，上学的时候也没有什么可总结的，但今年不写点血泪史我都不乐意。mdzz~ 感恩​ 首先要说的就是感恩。在这一年，挂着十多年”学生”标签的我终于摘掉了幼稚、天真的代名词。初来乍到懵懵懂懂，大环境下有时候会感到窒息。记得刚出来实习的时候要租房落脚，来来回回找了许多中介都没有合适的房子，不是价格贵就是地方太偏。最后多亏了老姐拖同事关系给我介绍了几套房子最终顺利住到了合适的房子。北京的房价真是让人一点想法都没有，有时想想还挺羡慕老姐那个时候买房子真是血赚，但也是当时刚需买了没得说。 ​ 在实习期间工资低的可怜，自己也没有攒钱只能疯狂给家里打call，这才维持能吃饱穿暖的温饱生活。这期间也得到了老姨的帮忙，顺利的实习里几个月时间让我初入互联网行业。 ​ 总之，要感恩家人，只有ta们才能在你困难的时候帮你渡过难关。 工作​ 五月三号我入职了现在这家公司，当初手里拿着两家offer最终还是等来这家的通知，相对来说这家公司我觉得更能让我成长毕竟公司前端就我一人：） ​ 公司项目多，我也是忙的要死。刚过来就接了几个后台项目和新上的项目，虽然前期开发遇到了一些困难但还是咬咬牙挺了过来项目转接也算顺利。虽然加班是常态但我也尽量当天的事当天办我是极度反感拖拖拉拉的办事状态。当时距离毕业还有两个月，论文还没收工，基本上是有空就写，讲道理我这论文写得蛮走心的真的是纯手工制作，耗费大量时间去写。虽然答辩时导师问的都是一切奇葩问题但自我感觉毕设做的还是相当满意。期间还有些事需要回老家、回学校也请了不少假但也没有托工作进度还是挺顺利的吧。就这样七月份转正正式成为来京务工人员，继续搬砖继续学习。在这家公司只能靠自己，不会的查，查不到的科学上网查总之google是个好东西。这半年多学到了很多同时也知道了自己还是弱，前面的路还很长。 ​ 这才工作了半年，回想起上学的时光是真tm幸福啊。什么都不用想，摇就完了。对于工作总体来说这一年收获颇丰，也认识到了以后的方向。所以说呢，打铁还需自身硬啊。 生活​ 这一年，我胖了近20斤：）我承认花自己挣的钱吃饭一点都不心疼，这菜没肉？打扰了。过年回家见谁谁说胖，照镜子看见自己自己都烦。所以在2018年新年之际在此立下flag，今年不瘦个三四十斤我回家过年。。（这是第几个flag了？？） ​ 这一年学着做了几道菜，是真的难吃。可能技能点没点上吧。还有就是花销状况，刚开始完全没有这个概念基本就是月光，花的飞起，后来也渐渐意识到需要攒点钱了。新的一年打算好好攒攒钱，买东西也要节制一些。不长远打算就当个旅游资金也是蛮好的。想想以后买房压力更大，所以还是节省点花销为好。 总而言之​ 新的一年就要有新的生活态度面对接下来的一切，有些事情也要自己学会承担、负责。特别喜欢一句话：总会有一天,你会活成自己想要的模样；以上。 ​","categories":[{"name":"个人","slug":"个人","permalink":"http://yoursite.com/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://yoursite.com/tags/个人/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"Gulp自动化构建工具","slug":"gulp自动化构建工具","date":"2017-06-07T03:20:56.000Z","updated":"2017-10-25T09:05:41.000Z","comments":true,"path":"2017/06/07/gulp自动化构建工具/","link":"","permalink":"http://yoursite.com/2017/06/07/gulp自动化构建工具/","excerpt":"","text":"Gulp.js 是基于 Node.js 构建的,利用 Node.js 流的威力,可以快速构建项目。 Gulp介绍​ Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。 Gulp安装1234$ sudo npm install -g gulp // 全局安装gulp$ gulp -v // 查看gulp版本号，是否安装成功$ npm init // 创建文件夹，初始化npm(项目名称不能为gulp)$ npm install gulp —save-dev // 当前文件夹安装本地gulp文件 ​ 上述命令执行完成后需要再创建一个gulpfile.js文件来用来配置gulp。 Gulp使用​ 我使用gulp最常用的功能就是压缩css,js代码和添加css代码中兼容浏览器前缀。这三个功能分别需要安装三个gulp插件：gulp-uglify（压缩js代码）、gulp-css（压缩css代码）、gulp-autoprefixer（css兼容浏览器前缀）。所以需要通过npm来安装这三个插件： 123$npm install gulp-uglify --save-dev$npm install gulp-css --save-dev$npm install gulp-autoprefixer --save-dev ​ 在项目中我们需要存放我们需要压缩的代码，在项目中创建一个src文件夹，其中存放js，css文件。 ​ |——src ​ |——-js ​ ——main.js ​ |——-css ​ ——main.css ​ 同理我们还需要创建一个压缩代码后存放文件的文件夹。 ​ |——–dist ​ |—— js ​ |——-css ​ 下面就要配置gulp文件了，在刚刚创建的gulpfile.js文件中进行配置。所有配置代码如下： 123456789101112131415161718192021222324252627var gulp = require('gulp');var uglify = require('gulp-uglify');var autoprefixer = require('gulp-autoprefixer');var cssMin = require('gulp-css');gulp.task('script',function()&#123; // 压缩js代码 return gulp.src('src/js/**/*.js') .pipe(uglify()) //引用插件 .pipe(gulp.dest('./dist/js')); //存放的位置&#125;);gulp.task('css',function()&#123; return gulp.src('src/css/**/*.css') .pipe(autoprefixer(&#123; //兼容性浏览器前缀添加 browsers:['last 40 versions'],//版本范围 cascade:false //是否美化属性值 默认是true 这里写false不需要 &#125;)) .pipe(cssMin()) //引用插件 .pipe(gulp.dest('./dist/css'));//存放的位置&#125;);gulp.task('default',['script','css'],function()&#123; console.log('任务完成');&#125;)//如果不需要兼容性前缀添加，直接将pipe(autoprefixer)任务这部分删除。其他同理。 ​ 配置好gulp后就可以将代码存放在src中，通过命令来进行相应操作： 1$ gulp //默认全部执行 1$ gulp script //仅压缩js代码 1$ gulp css //仅压缩css代码","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://yoursite.com/categories/构建工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"JavaScript面向对象","slug":"JavaScript面向对象","date":"2017-06-06T06:47:19.000Z","updated":"2017-10-25T08:02:02.000Z","comments":true,"path":"2017/06/06/JavaScript面向对象/","link":"","permalink":"http://yoursite.com/2017/06/06/JavaScript面向对象/","excerpt":"","text":"JavaScript面向对象理解对象​ 创建一个实例，为它添加属性和方法，如下代码： 12345678var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\";person.sayName = function()&#123;alert(this.name); &#125;; ​ 上面的例子中名为person就是一个对象，其中有三个属性name、age、job和一个方法sayName()。 设计原型原型模式1234567891011121314function Person()&#123; &#125;Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name); &#125;;var person1 = new Person(); person1.sayName(); //\"Nicholas\"var person2 = new Person();person2.sayName(); //\"Nicholas\" alert(person1.sayName == person2.sayName);//true ​ 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。 ​ 创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 ​ 以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，下图展示了各个对 象之间的关系。 更简单、实用的原型语法12345678910111213141516function Person()&#123; &#125;Person.prototype = &#123; constructor:Person, //指向所在函数指针 name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125; &#125;;var friend = new Person();alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //truealert(friend.constructor == Object);//true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"javascript，前端","slug":"javascript，前端","permalink":"http://yoursite.com/tags/javascript，前端/"}]},{"title":"Git使用","slug":"Git使用","date":"2017-06-05T07:59:19.000Z","updated":"2017-10-25T08:59:47.000Z","comments":true,"path":"2017/06/05/Git使用/","link":"","permalink":"http://yoursite.com/2017/06/05/Git使用/","excerpt":"","text":"Git的正确打开方式Git三个状态在Git中存在三个状态：工作区、暂存区、版本状态仓库。 工作区：工作区是我们在本地我们可以看得到的那一部分内容。例如在本地创建的文件夹里的文件，如果修改了文件中的内容可以通过 git status来查看是否文件有修改。 暂存区：当我们想要上传代码到git中首先要将工作区中的文件通过命令上传至git中的暂存区： 1$ git add . //add后面的.是将所有未最终的文件添加在缓存区中。.也可以使用-A代替，实现效果一样。 版本管理仓库：当我们的代码上传到指定服务器中后也，git版本状态中会自动存留一条此次上传文件的版本状态。通过命令可查询： 1$ git log 其中commit是版本识别标识，我们可以通过commit码来回滚到指定版本，命令如下： 1$ git reset --hard 80919da**** //commit码只需要输入前几位即可 git会自动识别 通过Git将文件提交至Github如果文件是第一次提交至github需要将需要上传的文件通过命令git初始化，命令如下: 1$ git init 工作区提交到暂存区： 1$ git add . 将本次提交生成一个标识来帮助我们查看： 1$ git commit -m”someText” 与github建立连接 12git remote add origin git@github.com：yourName / songProject.git //可在github创建一个库复制其git地址 提交文件至github 1git push -u origin master 更新文件更新文件基本与以上操作基本相似： 123$ git add.$ git commit -m&quot;someText&quot;$ git push 注意如果是第一次使用git需要设置用户信息： 12$ git config user.name &quot;username&quot;$ git config user.email &quot;user@email.com&quot; 查看是否设置成功： 12$ git config user.name $ git config user.email","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2017-04-12T05:29:50.000Z","updated":"2017-10-25T08:01:56.000Z","comments":true,"path":"2017/04/12/JavaScript闭包/","link":"","permalink":"http://yoursite.com/2017/04/12/JavaScript闭包/","excerpt":"","text":"闭包闭包算是JavaScript经常会碰到的问题。简单的说就是函数嵌套关系到作用域链的问题。 学习了一下阮一峰的闭包讲解，概括起来就是变量作用域，全局和局部变量的判断。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。所以在闭包中内存中会一直保存着局部变量。会占用内存，内存消耗大，对整体性能有影响。 eg：绑定每个span的click事件，让鼠标点击span的时候alert出对应的index 123456var spans = $(\"#divTest span\"); for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].onclick = function() &#123; alert(i); &#125; &#125; 很简单的功能可是却偏偏出错了，每次alert出的值都是4，所以然者何？ 上面代码在页面加载后就会执行，当i的值为4的时候，判断条件不成立，for循环执行完毕，但是因为每个span的onclick方法这时候为内部函数，所以i被闭包引用，内存不能被销毁，i的值会一直保持4，直到程序改变它或者所有的onclick函数销毁（主动把函数赋为null或者页面卸载）时才会被回收。 这样每次我们点击span的时候，onclick函数会查找i的值（作用域链是引用方式），一查等于4，然后就alert给我们了。而第二种方式是使用了一个立即执行的函数又创建了一层闭包，函数声明放在括号内就变成了表达式，后面再加上括号就是调用了，这时候把i当参数传入，函数立即执行，num保存每次i的值。 12345678910var spans2 = $(\"#divTest2 span\"); $(document).ready(function() &#123; for (var i = 0; i &lt; spans2.length; i++) &#123; (function(num) &#123; spans2[i].onclick = function() &#123; alert(num); &#125; &#125;)(i); &#125; &#125;); 逃脱JavaScript允许像传递任何类型的数据一样传递函数，也就是说JavaScript中的内部函数能够逃脱定义他们的外部函数。 全局变量1234567891011var globalVar;function outerFn() &#123; console.log(\"Outer function\"); function innerFn() &#123; console.log(\"Inner function\"); &#125; globalVar = innerFn;&#125;outerFn();globalVar(); 调用outerFn时会修改全局变量globalVar，这时候它的引用变为innerFn，此后调用globalVar和调用innerFn一样。这时在outerFn外部直接调用innerFn仍然会导致错误，这是因为内部函数虽然通过把引用保存在全局变量中实现了逃脱，但这个函数的名字依然只存在于outerFn的作用域中。 返回值可以通过在父函数的返回值来获得内部函数引用 123456789function outerFn() &#123; console.log(\"Outer function\"); function innerFn() &#123; console.log(\"Inner function\"); &#125; return innerFn;&#125;var fnRef = outerFn();fnRef(); 这里并没有在outerFn内部修改全局变量，而是从outerFn中返回了一个对innerFn的引用。通过调用outerFn能够获得这个引用，而且这个引用可以可以保存在变量中。 闭包的优缺点使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}