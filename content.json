{"meta":{"title":"Asimov","subtitle":"Try to find me.","description":"Try to find me.","author":"Asimov","url":"http://vcodes.me"},"pages":[{"title":"title","date":"2018-03-26T03:27:10.000Z","updated":"2018-08-17T03:47:46.000Z","comments":true,"path":"mkMod.html","permalink":"http://vcodes.me/mkMod.html","excerpt":"xxx","text":"xxx 正文"},{"title":"关于","date":"2019-01-15T03:19:31.696Z","updated":"2019-01-15T03:19:31.690Z","comments":true,"path":"about/index.html","permalink":"http://vcodes.me/about/index.html","excerpt":"","text":"三餐与四季。 Email: meetguardian@outlook.com"},{"title":"相册","date":"2019-01-15T03:49:38.422Z","updated":"2019-01-15T03:49:38.416Z","comments":true,"path":"gallery/index.html","permalink":"http://vcodes.me/gallery/index.html","excerpt":"","text":""},{"title":"2017年终总结","date":"2018-01-15T11:00:10.000Z","updated":"2018-06-20T09:16:03.000Z","comments":true,"path":"own/2017年终总结.html","permalink":"http://vcodes.me/own/2017年终总结.html","excerpt":"年末断断续续也写了一些觉得有些杂乱，趁着最近不忙还是要把总结完整的写一写。","text":"年末断断续续也写了一些觉得有些杂乱，趁着最近不忙还是要把总结完整的写一写。 感恩首先要说的就是感恩。在这一年，挂着十多年”学生”标签的我终于摘掉了幼稚、天真的代名词。初来乍到懵懵懂懂，大环境下有时候会感到窒息。记得刚出来实习的时候要租房落脚，来来回回找了许多中介都没有合适的房子，不是价格贵就是地方太偏。最后多亏了老姐拖同事关系给我介绍了几套房子最终顺利住到了合适的房子。北京的房价真是让人一点想法都没有，有时想想还挺羡慕老姐那个时候买房子真是血赚，但也是当时刚需买了没得说。 在实习期间工资低的可怜，自己也没有攒钱只能疯狂给家里打call，这才维持能吃饱穿暖的温饱生活。这期间也得到了老姨的帮忙，顺利的实习里几个月时间让我初入互联网行业。 总之，要感恩家人，只有ta们才能在你困难的时候帮你渡过难关。 工作五月三号我入职了现在这家公司，当初手里拿着两家offer最终还是等来这家的通知，相对来说这家公司我觉得更能让我成长毕竟公司前端就我一人：） 公司项目多，我也是忙的要死。刚过来就接了几个后台项目和新上的项目，虽然前期开发遇到了一些困难但还是咬咬牙挺了过来项目转接也算顺利。虽然加班是常态但我也尽量当天的事当天办我是极度反感拖拖拉拉的办事状态。当时距离毕业还有两个月，论文还没收工，基本上是有空就写，讲道理我这论文写得蛮走心的真的是纯手工制作，耗费大量时间去写。虽然答辩时导师问的都是一切奇葩问题但自我感觉毕设做的还是相当满意。期间还有些事需要回老家、回学校也请了不少假但也没有托工作进度还是挺顺利的吧。就这样七月份转正正式成为来京务工人员，继续搬砖继续学习。在这家公司只能靠自己，不会的查，查不到的科学上网查总之google是个好东西。这半年多学到了很多同时也知道了自己还是弱，前面的路还很长。 ​ 这才工作了半年，回想起上学的时光是真tm幸福啊。什么都不用想，摇就完了。对于工作总体来说这一年收获颇丰，也认识到了以后的方向。所以说呢，打铁还需自身硬啊。 生活这一年，我胖了近20斤：） 这一年学着做了几道菜，是真的难吃。可能技能点没点上吧。还有就是花销状况，刚开始完全没有这个概念基本就是月光，花的飞起，后来也渐渐意识到需要攒点钱了。新的一年打算好好攒攒钱，买东西也要节制一些。不长远打算就当个旅游资金也是蛮好的。想想以后买房压力更大，所以还是节省点花销为好。 总而言之新的一年就要有新的生活态度面对接下来的一切，有些事情也要自己学会承担、负责。特别喜欢一句话：总会有一天,你会活成自己想要的模样；以上。 ​"},{"title":"JavaScript面向对象","date":"2017-06-06T06:47:19.000Z","updated":"2018-12-21T02:59:16.663Z","comments":true,"path":"own/JavaScript面向对象.html","permalink":"http://vcodes.me/own/JavaScript面向对象.html","excerpt":"new一个对象","text":"new一个对象 理解对象创建一个实例，为它添加属性和方法，如下代码： 12345678var person = new Object(); person.name = \"Nicholas\"; person.age = 29; person.job = \"Software Engineer\";person.sayName = function()&#123;alert(this.name); &#125;; 上面的例子中名为person就是一个对象，其中有三个属性name、age、job和一个方法sayName()。 设计原型原型模式1234567891011121314function Person()&#123; &#125;Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function()&#123; alert(this.name); &#125;;var person1 = new Person(); person1.sayName(); //\"Nicholas\"var person2 = new Person();person2.sayName(); //\"Nicholas\" alert(person1.sayName == person2.sayName);//true 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。 创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 proto；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，下图展示了各个对 象之间的关系。 更简单、实用的原型语法12345678910111213141516function Person()&#123; &#125;Person.prototype = &#123; constructor:Person, //指向所在函数指针 name : \"Nicholas\", age : 29, job: \"Software Engineer\", sayName : function () &#123; alert(this.name); &#125; &#125;;var friend = new Person();alert(friend instanceof Object); //truealert(friend instanceof Person); //truealert(friend.constructor == Person); //truealert(friend.constructor == Object);//true"}],"posts":[{"title":"Taro + Dva 实战小结","slug":"Taro + Dva 实战小结","date":"2019-01-07T13:19:40.000Z","updated":"2019-01-28T06:57:13.594Z","comments":true,"path":"2019/01/07/Taro + Dva 实战小结/","link":"","permalink":"http://vcodes.me/2019/01/07/Taro + Dva 实战小结/","excerpt":"技术栈：React + Taro + Dva Taro 是基于 Reac t语法规范的重微信小程序的框架，它同时可以完成多端适配的需求。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等）运行的代码。 Dva 是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 这里我仅对微信小程序开发进行小结。","text":"技术栈：React + Taro + Dva Taro 是基于 Reac t语法规范的重微信小程序的框架，它同时可以完成多端适配的需求。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等）运行的代码。 Dva 是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 这里我仅对微信小程序开发进行小结。 Taro 特性React 语法风格 Taro遵循React语法规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用Taro进行开发可以获得和 React 一致的开发体验。 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Taro, &#123; Component &#125; from &apos;@tarojs/taro&apos;import &#123; View, Button &#125; from &apos;@tarojs/components&apos;export default class Index extends Component &#123; constructor () &#123; super(...arguments) this.state = &#123; title: &apos;首页&apos;, list: [1, 2, 3] &#125; &#125; componentWillMount () &#123;&#125; componentDidMount () &#123;&#125; componentWillUpdate (nextProps, nextState) &#123;&#125; componentDidUpdate (prevProps, prevState) &#123;&#125; shouldComponentUpdate (nextProps, nextState) &#123; return true &#125; add = (e) =&gt; &#123; // dosth &#125; render () &#123; return ( &lt;View className=&apos;index&apos;&gt; &lt;View className=&apos;title&apos;&gt;&#123;this.state.title&#125;&lt;/View&gt; &lt;View className=&apos;content&apos;&gt; &#123;this.state.list.map(item =&gt; &#123; return ( &lt;View className=&apos;item&apos;&gt;&#123;item&#125;&lt;/View&gt; ) &#125;)&#125; &lt;Button className=&apos;add&apos; onClick=&#123;this.add&#125;&gt;添加&lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125; ###Dva 概念 数据流向 数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State，所以在 dva 中，数据流向非常清晰简明，并且思路基本跟开源社区保持一致（也是来自于开源社区）。 项目运行123456$ npm install -g @tarojs/cli$ taro init myApp$ npm run dev:weapp$ npm install dva-cli -g$ npm i dva-core dva-loading --save 目录结构123456789101112131415161718192021222324252627├── .temp ├── .rn_temp ├── dist ├── config // Taro配置目录│ ├── dev.js // 开发时配置│ ├── index.js // 默认配置│ └── prod.js // 打包时配置├── static // 静态文件├── src // 源码目录│ ├── components // 组件│ ├── models // redux models│ │ └── common.js │ │ └── index.js │ ├── pages // 页面文件目录│ │ └── home│ │ ├── index.js // 页面逻辑│ │ ├── index.scss // 页面样式│ │ ├── model.js // 页面models│ │ └── service.js // 页面api│ ├── styles │ ├── utils │ │ └── dva.js //dva配置│ │ └── request.js //网络请求封装│ ├── app.js // 入口文件│ └── index.html├── package.json dav配置 1234567891011121314151617181920212223242526272829303132333435363738394041dva.jsimport Taro from '@tarojs/taro'; import &#123; create &#125; from 'dva-core';import &#123; createLogger &#125; from 'redux-logger';import createLoading from 'dva-loading';let app;let store;let dispatch;function createApp(opt) &#123; // redux日志 // opt.onAction = [createLogger()]; app = create(opt); app.use(createLoading(&#123;&#125;)); // 适配支付宝小程序 if (Taro.getEnv() === Taro.ENV_TYPE.ALIPAY) &#123; global = &#123;&#125;; &#125; if (!global.registered) opt.models.forEach(model =&gt; app.model(model)); global.registered = true; app.start(); store = app._store; app.getStore = () =&gt; store; dispatch = store.dispatch; app.dispatch = dispatch; return app;&#125;export default &#123; createApp, getDispatch() &#123; return app.dispatch; &#125;&#125; 入口导入dva 12345678app.jsimport dva from './utils/dva'const dvaApp = dva.createApp(&#123; initialState: &#123;&#125;, models: models,&#125;);const store = dvaApp.getStore(); 封装request 123456789101112131415161718192021222324252627282930313233343536import Taro from '@tarojs/taro';// const request_data = &#123;// platform: 'wap',// rent_mode: 2,// &#125;;const baseUrl = 'https://xxxx.com/api/'export default (options = &#123; method: 'GET', data: &#123;&#125; &#125;) =&gt; &#123; return Taro.request(&#123; url: baseUrl + options.url, data: &#123; ...options.data &#125;, header: &#123; 'Content-Type': 'application/json', &#125;, method: options.method.toUpperCase(), &#125;).then((res) =&gt; &#123; const &#123; statusCode, data &#125; = res; if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) &#123; if (data.msg !== 'success') &#123; Taro.showToast(&#123; title: `$&#123;res.data.msg&#125;~` || res.data.code, icon: 'none', mask: true, &#125;); &#125; return data; &#125; else &#123; throw new Error(`网络请求错误，状态码$&#123;statusCode&#125;`); &#125; &#125;)&#125; 创建page 用一个累加器的例子演示taro与dav的配合，通过请求接口返回值判断是否允许操作累加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091│ ├── pages │ │ └── home│ │ ├── index.js │ │ ├── index.scss │ │ ├── model.js │ │ └── service.js service.jsimport Request from &apos;../../utils/request&apos;export const optionAllow = data =&gt; Request(&#123; url: &apos;xxx&apos;, method: &apos;GET&apos;, data&#125;)index.jsimport Taro, &#123; Component &#125; from &apos;@tarojs/taro&apos;import &#123; View, Button &#125; from &apos;@tarojs/components&apos;import &#123; connect &#125; from &apos;@tarojs/redux&apos;import * as lineApi from &apos;./server&apos;import &apos;./index.scss&apos;@connect((&#123; home &#125;) =&gt; (&#123; ...home&#125;))export default class Home extends Component &#123; config = &#123; navigationBarTitleText: &apos;首页&apos; &#125; constructor() &#123; super(...arguments) &#125; componentDidMount = () =&gt; &#123; &#125; handleAddButton()&#123; this.props.dispatch(&#123; type:&apos;home/handleAddNumber&apos; &#125;) &#125; render()&#123; const &#123; amount &#125; = this.props return( &lt;View&gt; &lt;View&gt;总数：&#123; amount &#125;&lt;/View&gt; &lt;Button onClick = &#123; this.handleAddButton &#125; &gt;+&lt;/Button&gt; &lt;/View&gt; ) &#125;&#125;model.jsimport * as homeApi from &apos;./server&apos;export default &#123; namespace:&apos;home&apos;, state:&#123; amount:0, &#125;, effects:&#123; *handleAddNumber(_,&#123;call,put,select&#125;)&#123; const &#123; amount &#125; = yield select( state =&gt; state.home ) const res = yield call(homeApi.optionAllow,&#123;status:&apos;add&apos;&#125;) if(!res.data) return yield put(&#123; type:&apos;save&apos;, payload:&#123; amount: amount + 1 &#125; &#125;) &#125; &#125;, reducers:&#123; save(state, &#123; payload &#125;)&#123; return &#123; ...state, ...payload &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://vcodes.me/tags/React/"},{"name":"Taro","slug":"Taro","permalink":"http://vcodes.me/tags/Taro/"},{"name":"Dva","slug":"Dva","permalink":"http://vcodes.me/tags/Dva/"}]},{"title":"Vue按需加载ECharts模块","slug":"Vue按需加载ECharts模块","date":"2018-06-10T13:07:10.000Z","updated":"2018-12-21T03:14:25.373Z","comments":true,"path":"2018/06/10/Vue按需加载ECharts模块/","link":"","permalink":"http://vcodes.me/2018/06/10/Vue按需加载ECharts模块/","excerpt":"Vue按需加载ECharts模块","text":"Vue按需加载ECharts模块 当我们只需要ECharts的线和工具提示模块的时候，我们会这么写： 注：用 require 不用 import 引入是因为 import 需要详细的路径 123import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/line'import 'echarts/lib/component/tooltip' 当引入了这个插件后，我们只需要这个写： 12345// eslint-disable-next-lineconst echarts = equire([ 'line', 'tooltip']) 这个插件会自动帮我们转化为上面的形式 安装1npm i babel-plugin-equire -D 然后，在.babelrc文件中添加该插件 12345678&#123; \"plugins\": [ // other plugins ... \"equire\" ]&#125; 用法新建一个文件initEcharts.js用于初始化ECharts模块，然后编写如下代码： 123456789@/src/utils/initEcharts.js// eslint-disable-next-lineconst echarts = equire([ 'line', 'tooltip'])export default echarts 在需要用到echarts的地方引入上面的initEcharts.js文件 1import echarts from '@/src/utils/initEcharts' 这样，最后打包出来的文件就只有包含ECharts的核心模块和line / bar两个图表模块 Echarts可以按需引入的模块列表见 https://github.com/ecomfe/echarts/blob/master/index.js","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://vcodes.me/tags/vue/"}]},{"title":"JavaScript代码库(封装)","slug":"JavaScript代码库(封装)","date":"2018-05-12T14:12:25.000Z","updated":"2018-08-17T09:19:55.000Z","comments":true,"path":"2018/05/12/JavaScript代码库(封装)/","link":"","permalink":"http://vcodes.me/2018/05/12/JavaScript代码库(封装)/","excerpt":"常用工具库，持续更新。。。","text":"常用工具库，持续更新。。。 去除字符串空格12345678910//去除空格 type 1-所有空格 2-前后空格 3-前空格 4-后空格function trim(str,type)&#123; switch (type)&#123; case 1:return str.replace(/\\s+/g,\"\"); case 2:return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); case 3:return str.replace(/(^\\s*)/g, \"\"); case 4:return str.replace(/(\\s*$)/g, \"\"); default:return str; &#125;&#125; 字母大小写切换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*type1:首字母大写 2：首页母小写3：大小写转换4：全部大写5：全部小写 * *///changeCase('asdasd',1)//Asdasdfunction changeCase(str,type)&#123; function ToggleCase(str) &#123; var itemText = \"\" str.split(\"\").forEach( function (item) &#123; if (/^([a-z]+)/.test(item)) &#123; itemText += item.toUpperCase(); &#125; else if (/^([A-Z]+)/.test(item)) &#123; itemText += item.toLowerCase(); &#125; else&#123; itemText += item; &#125; &#125;); return itemText; &#125; switch (type) &#123; case 1: return str.replace(/^(\\w)(\\w+)/, function (v, v1, v2) &#123; return v1.toUpperCase() + v2.toLowerCase(); &#125;); case 2: return str.replace(/^(\\w)(\\w+)/, function (v, v1, v2) &#123; return v1.toLowerCase() + v2.toUpperCase(); &#125;); case 3: return ToggleCase(str); case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125; 字符串循环复制12345678910//repeatStr(str-&gt;字符串, count-&gt;次数)//repeatStr('123',3)//\"123123123\"function repeatStr(str, count) &#123; var text = ''; for (var i = 0; i &lt; count; i++) &#123; text += str; &#125; return text;&#125; 字符串替换12345//字符串替换(字符串,要替换的字符,替换成什么)function replaceAll(str,AFindText,ARepText)&#123; raRegExp = new RegExp(AFindText,\"g\"); return str.replace(raRegExp,ARepText);&#125; 手机号替换*等1234567891011121314151617181920212223242526272829303132333435363738//replaceStr(字符串,字符格式, 替换方式,替换的字符（默认*）)function replaceStr(str, regArr, type,ARepText) &#123; var regtext = '', Reg = null,replaceText=ARepText||'*'; //replaceStr('18819322663',[3,5,3],0) //188*****663 //repeatStr是在上面定义过的（字符串循环复制），大家注意哦 if (regArr.length === 3 &amp;&amp; type === 0) &#123; regtext = '(\\\\w&#123;' + regArr[0] + '&#125;)\\\\w&#123;' + regArr[1] + '&#125;(\\\\w&#123;' + regArr[2] + '&#125;)' Reg = new RegExp(regtext); var replaceCount = repeatStr(replaceText, regArr[1]); return str.replace(Reg, '$1' + replaceCount + '$2') &#125; //replaceStr('asdasdasdaa',[3,5,3],1) //***asdas*** else if (regArr.length === 3 &amp;&amp; type === 1) &#123; regtext = '\\\\w&#123;' + regArr[0] + '&#125;(\\\\w&#123;' + regArr[1] + '&#125;)\\\\w&#123;' + regArr[2] + '&#125;' Reg = new RegExp(regtext); var replaceCount1 = repeatSte(replaceText, regArr[0]); var replaceCount2 = repeatSte(replaceText, regArr[2]); return str.replace(Reg, replaceCount1 + '$1' + replaceCount2) &#125; //replaceStr('1asd88465asdwqe3',[5],0) //*****8465asdwqe3 else if (regArr.length === 1 &amp;&amp; type == 0) &#123; regtext = '(^\\\\w&#123;' + regArr[0] + '&#125;)' Reg = new RegExp(regtext); var replaceCount = repeatSte(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125; //replaceStr('1asd88465asdwqe3',[5],1,'+') //\"1asd88465as+++++\" else if (regArr.length === 1 &amp;&amp; type == 1) &#123; regtext = '(\\\\w&#123;' + regArr[0] + '&#125;$)' Reg = new RegExp(regtext); var replaceCount = repeatSte(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125;&#125; 检测密码强度1234567891011121314151617181920212223242526//checkPwd('12asdASAD')//3(强度等级为3)function checkPwd(str) &#123; var nowLv = 0; if (str.length &lt; 6) &#123; return nowLv &#125; ; if (/[0-9]/.test(str)) &#123; nowLv++ &#125; ; if (/[a-z]/.test(str)) &#123; nowLv++ &#125; ; if (/[A-Z]/.test(str)) &#123; nowLv++ &#125; ; if (/[\\.|-|_]/.test(str)) &#123; nowLv++ &#125; ; return nowLv;&#125; 随机码12345678910111213//count取值范围0-36//randomNumber(10)//\"2584316588472575\"//randomNumber(14)//\"9b405070dd00122640c192caab84537\"//Math.random().toString(36).substring(2);//\"83vhdx10rmjkyb9\"function randomNumber(count)&#123; return Math.random().toString(count).substring(2);&#125; 查找字符串123456function countStr (str,strSplit)&#123; return str.split(strSplit).length-1&#125;var strTest='sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967'//countStr(strTest,'blog')//6 cookie1234567891011121314151617181920212223//cookie//设置cookiefunction setCookie(name,value,iDay)&#123; var oDate=new Date(); oDate.setDate(oDate.getDate()+iDay); document.cookie=name+'='+value+';expires='+oDate;&#125;//获取cookiefunction getCookie(name)&#123; var arr=document.cookie.split('; '); for(var i=0;i&lt;arr.length;i++)&#123; var arr2=arr[i].split('='); if(arr2[0]==name) &#123; return arr2[1]; &#125; &#125; return '';&#125;//删除cookiefunction removeCookie(name)&#123; setCookie(name,1,-1);&#125; localStorage1234567891011121314151617181920212223242526272829var Storage = (function()&#123; return &#123; set: function(key, value, expireSeconds)&#123; localStorage[key] = JSON.stringify(&#123; value: value, expired: expireSeconds===undefined?undefined:Date.now() + 1000*expireSeconds &#125;) &#125;, get: function(key)&#123; if(localStorage[key] === undefined)&#123; return &#125; var o = JSON.parse(localStorage[key]) if(o.expired === undefined || Date.now() &lt; o.expired)&#123; return o.value &#125;else&#123; delete localStorage[key] &#125; &#125; &#125;&#125;)()Storage.set('name', 'sss’) Storage.set('age', 2, 30) ; //设置 name 字段存储的值为'sss’Storage.set('teachers', ['a', 'b', 'c'], 60) Storage.get('name') // ‘sss’Storage.get('age') // 如果不超过30秒，返回数字类型的2；如果超过30秒，返回 undefined，并且 localStorage 里清除 age 字段Storage.get('teachers') //如果不超过60秒，返回数组； 如果超过60秒，返回 undefined，并且 localStorage 里清除 teachers 字段 Date日期时间部分12345678910111213141516//到某一个时间的倒计时//getEndTime('2017/7/22 16:0:0')//\"剩余时间6天 2小时 28 分钟20 秒\"function getEndTime(endTime)&#123; var startDate=new Date(); //开始时间，当前时间 var endDate=new Date(endTime); //结束时间，需传入时间参数 var t=endDate.getTime()-startDate.getTime(); //时间差的毫秒数 var d=0,h=0,m=0,s=0; if(t&gt;=0)&#123; d=Math.floor(t/1000/3600/24); h=Math.floor(t/1000/60/60%24); m=Math.floor(t/1000/60%60); s=Math.floor(t/1000%60); &#125; return \"剩余时间\"+d+\"天 \"+h+\"小时 \"+m+\" 分钟\"+s+\" 秒\";&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"}]},{"title":"JavaScript Class的基本语法","slug":"JavaScript Class的基本语法","date":"2018-05-05T13:54:12.000Z","updated":"2018-08-17T09:20:18.000Z","comments":true,"path":"2018/05/05/JavaScript Class的基本语法/","link":"","permalink":"http://vcodes.me/2018/05/05/JavaScript Class的基本语法/","excerpt":"在ES6中的Class语法，并不是真正的以类为基础(class-base)的新物件导向，根本上还是以原型为基础(prototype-based)，它只是个语法糖。之所以加入Class的目的并不是要建立一个新模型而是为了提供更为简洁的语法来继承。目的就是提供一个让开发者可选择的新语法导向。","text":"在ES6中的Class语法，并不是真正的以类为基础(class-base)的新物件导向，根本上还是以原型为基础(prototype-based)，它只是个语法糖。之所以加入Class的目的并不是要建立一个新模型而是为了提供更为简洁的语法来继承。目的就是提供一个让开发者可选择的新语法导向。 ES6之前创建一个造构造函数，然后new实例化这个函数： 123456789function shirt (color,size)&#123; this.color = color this.size = size&#125;shirt.prototype.pick = function()&#123; console.log(`this shirt color is $&#123;this.color&#125;,size is $&#123;this.size&#125;`)&#125;const shop = new shirt('red','xl')shop.pick() Class介绍类声明定义一个类的一种方法是使用一个类声明。要声明一个类，要使用带有class关键字的类名： 123456class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; 函数声明和类声明之间的一个重要区别是函数声明会提升，类声明不会。你首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个error。 用原型和静态方法包装类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125; classMod()&#123; return 'hi' &#125;&#125;Foo.classMethod() // 'hello'Foo.classMod() //\"TypeError: Foo.classMod is not a functionvar foo = new Foo();foo.classMethod() // TypeError: foo.classMethod is not a functionfoo.classMod() //'hi' 使用 extends 创建子类extends关键字在类声明或类表达式中用于创建一个类作为另一个类的一个子类。 12345678910111213141516171819class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;var d = new Dog('Mitzie');// 'Mitzie barks.'d.speak(); 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super() 也可以扩展传统的基于函数的“类”： 1234567891011121314151617function Animal (name) &#123; this.name = name; &#125;Animal.prototype.speak = function () &#123; console.log(this.name + ' makes a noise.');&#125;class Dog extends Animal &#123; speak() &#123; super.speak(); console.log(this.name + ' barks.'); &#125;&#125;var d = new Dog('Mitzie');// Mitzie makes a noise.d.speak();","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://vcodes.me/tags/ES6/"}]},{"title":"JavaScript Await与Async","slug":"JavaScript Await与Async","date":"2018-04-20T12:17:42.000Z","updated":"2018-12-21T02:57:22.664Z","comments":true,"path":"2018/04/20/JavaScript Await与Async/","link":"","permalink":"http://vcodes.me/2018/04/20/JavaScript Await与Async/","excerpt":"Promise已经初步的解决了回调地域，但是蛋疼的then()一样会令人窒息。那么有没有更好的方案呢？答案就是ES7的async/await。async/await应该是目前较完美的异步方案了","text":"Promise已经初步的解决了回调地域，但是蛋疼的then()一样会令人窒息。那么有没有更好的方案呢？答案就是ES7的async/await。async/await应该是目前较完美的异步方案了 例子123456789101112131415let PromiseDemo = function(time)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; resolve() &#125;,time) &#125; &#125;) var toStart = async function()&#123; console.log('start') await PromiseDemo(300) console.log('end')&#125;toStart() 控制台先输出’start’, 300ms后输出’end’。 规则 async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…） 获得返回值await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值。 1234567891011121314let PromiseDemo = function(time)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; resolve('ok') &#125;,time) &#125; &#125;)var toStart = async function()&#123; let result = await PromiseDemo(300) console.log(result) // 'ok’&#125;toStart() 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。 123456789101112131415161718192021let PromiseDemo = function(time)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(()=&gt;&#123; reject('error') //返回错误 &#125;,time) &#125; &#125;)var toStart = async function()&#123; try&#123; console.log('start'); let result = await PromiseDemo(300) //以下代码不会被执行('end') console.log('end'); &#125;catch(err)&#123; console.log(err) // 捕捉 `error` &#125; &#125;toStart()","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://vcodes.me/tags/ES6/"}]},{"title":"Git进阶-分支","slug":"Git进阶-分支","date":"2018-03-26T03:27:10.000Z","updated":"2019-01-14T06:49:09.698Z","comments":true,"path":"2018/03/26/Git进阶-分支/","link":"","permalink":"http://vcodes.me/2018/03/26/Git进阶-分支/","excerpt":"为什么要创建分支？","text":"为什么要创建分支？ 需求假如我们开发完成了一个项目并且已经上线，接下来开始迭代开发。如果线上的项目出现了一个严重的bug，这就需要我们放下手头的开发去解决这个bug然后再发布一个新版本。如果在线上修改的话并不现实，如果操作失误会造成更大的损失，这时我们就需要用的git的分支来解决这个问题。 如下所示： master是项目代码的主干，所有最终上线的代码都在master上，从v1.0版本一直优化到v1.3版本，在v1.3版本出现bug，这时我们就要在v1.3这个版本创建一个分支debug分支，在这个分支上去修复bug。修复完成后将v1.5版本合并到master主分支v2.1版本上即可，这样接下来就可以继续迭代开发。 分支的创建首先查看一下项目提交记录 1$ git log 假如项目在v1.4版本中有bug需要进行处理，那么我们就要在第三次提交的v1.4版本创建一个修复版本进行修复。 我们要切换到第三次提交的版本上。 1$ git checkout 73821029954db497bdc0373242df882405479b97 切换成功后开始建立分支 1$ git branch developer(分支名称) 查询是否创建成功 1$ git branch developer存在说明创建成功。 接下来我们切换到developer分支上进行开发 1$ git checkout developer 当我们将bug修复完成后进行提交 1234$ git add .$ git commit -m&quot;developer分支的第一次提交&quot;//确定一下是否提交成功$ git log 分支的合并我们先切换到主分支 1$ git checkout master 然后在进行合并 1$ git merge developer 合并成功 如果以后不打算在使用这个分支了,接下来就可以把这个分支删除 1$ git branch -D developer 在查看一下确认一下是否删除成功 这样整套流程就已经完成了。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://vcodes.me/tags/工具/"},{"name":"Git","slug":"Git","permalink":"http://vcodes.me/tags/Git/"}]},{"title":"Promise解析","slug":"Promise解析","date":"2018-03-26T03:27:10.000Z","updated":"2018-08-17T03:35:39.000Z","comments":true,"path":"2018/03/26/Promise解析/","link":"","permalink":"http://vcodes.me/2018/03/26/Promise解析/","excerpt":"Promise的产生就是为了解决回调地域的问题，当写了很多回调逻辑就很难搞清楚。利用Promise的链式调用就会清晰很多。","text":"Promise的产生就是为了解决回调地域的问题，当写了很多回调逻辑就很难搞清楚。利用Promise的链式调用就会清晰很多。 简单的例子12345678910111213141516171819//假设和朋友去看电影，在网上买票的例子：const SeeAMovie = new Promise((resolve,reject) =&gt;&#123; if(ticket)&#123; //买到票 resolve('nice') &#125;else&#123; //没买到票 reject('sad') &#125;&#125;)//无论买没买到要告诉朋友结果SeeAMovie.then( res =&gt;&#123; console.log('买到票了') &#125;, reason =&gt;&#123; console.log('票卖光了') &#125;) 123456789101112131415161718192021222324252627282930313233//1秒钟之后输出 fn1, 再过1秒输出 fn2, 再过1秒输出 fn3 function fn1() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn1...') resolve() &#125;, 1000) &#125;)&#125;function fn2() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn2...') resolve() &#125;, 1000) &#125;)&#125;function fn3() &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; console.log('fn3...') resolve() &#125;, 1000) &#125;)&#125;function onerror() &#123; console.log('error')&#125;fn1().then(fn2).then(fn3).catch(onerror) Promise有几个静态方法，无需实例化既可使用 Promise.all() (传入一个Promise数组, 等待所有代码完成, 或第一个代码失败) 123456789101112131415161718const funA = 'test'const funB = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('1000') &#125;,1000)&#125;)const funC = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('2000') &#125;,2000)&#125;)Promise.all([funA,funB,funC]).then(result=&gt;&#123; console.log(result) // 2秒后打印 ['test', '1000', '2000'] &#125;) Promise.race() (传入一个promise数组，当其中一个完成或失败，则采用该promise值) 123456789101112131415161718const funA = 'test'const funB = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('1000') &#125;,1000)&#125;)const funC = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('2000') &#125;,2000)&#125;)Promise.all([funA,funB,funC]).then(result=&gt;&#123; console.log(result) // 2秒后打印 ['test', '1000', '2000'] &#125;) Promise.race() (传入一个promise数组，当其中一个完成或失败，则采用该promise值) 1234567891011121314const funB = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('1000') &#125;,1000)&#125;)const funC = new Promise((resolve,reject) =&gt; &#123; setTimeOut(() =&gt;&#123; resolve('2000') &#125;,2000)&#125;)Promise.race([funA,funB,funC]).then(result=&gt;&#123; console.log(result) // 1秒后打印 ['1000'] &#125;)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"}]},{"title":"小程序框架WePY","slug":" 小程序框架WePY","date":"2018-02-27T08:42:16.000Z","updated":"2018-12-21T02:58:24.688Z","comments":true,"path":"2018/02/27/ 小程序框架WePY/","link":"","permalink":"http://vcodes.me/2018/02/27/ 小程序框架WePY/","excerpt":"原生小程序的结构和组件化实在是不喜欢，鹅厂自家的WePY框架借鉴了Vue.js的语法风格和功能特性写起来到是方便很多，但也有深坑。","text":"原生小程序的结构和组件化实在是不喜欢，鹅厂自家的WePY框架借鉴了Vue.js的语法风格和功能特性写起来到是方便很多，但也有深坑。 WePY项目创建全局安装或更新WePY命令行工具 1npm install wepy-cli -g 在开发目录中生成Demo开发项目 12wepy new myproject# 1.7.0之后的版本使用 wepy init standard myproject 初始化项目，使用 wepy list 查看项目模板 切换至项目目录 12cd myprojectnpm istall 开启实时编译 12wepy build —watch|** 报错的话看是否是eslint问题 wepy.config.js -&gt; eslint: false, 需要注意几点1.使用微信开发者工具–&gt;添加项目，项目目录请选择dist目录。 2.微信开发者工具–&gt;项目–&gt;关闭ES6转ES5。 3.微信开发者工具–&gt;项目–&gt;关闭上传代码时样式自动补全。 4.微信开发者工具–&gt;项目–&gt;关闭代码压缩上传。 小程序设置更改后如出现 编译.wxml文件错误重启软件即可 代码规范小程序入口、页面、组件文件名的后缀为.wpy 可以使用ES6、promise开发 事件绑定语法使用优化语法代替： 原 bindtap=&quot;click&quot; 替换为 @tap=&quot;click&quot;，原catchtap=&quot;click&quot;替换为`@tap.stop=”click”`。 原 capture-bind:tap=&quot;click&quot; 替换为 `@tap.capture=”click”，原capture-catch:tap=”click”替换为@tap.capture.stop=”click”`。。 数据绑定方式WePY使用脏数据检查对setData进行封装，在函数运行周期结束时执行脏数据检查，一来可以不用关心页面多次setData是否会有性能上的问题，二来可以更加简洁去修改数据实现绑定，不用重复去写setData方法。代码如下： 1this.title = 'this is title'; 在我写项目时需要滑动触底刷新，当时用的定时器做数据获取模拟就出现了bug，这时 需注意的是，在异步函数中更新数据的时，必须手动调用$apply方法，才会触发脏数据检查流程的运行。如： 1234setTimeout(() =&gt; &#123; this.title = 'this is title'; this.$apply();&#125;, 3000); 请求数据12345678wepy.request(&#123; url: \"###\", method: \"GET\", header: &#123;header&#125;, success: function(res) &#123; &#125; &#125;); Component组件实例对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 错误示例import wepy from 'wepy';export default class MyComponent extends wepy.component &#123; methods = &#123; bindtap () &#123; let rst = this.commonFunc(); // doSomething &#125;, bindinput () &#123; let rst = this.commonFunc(); // doSomething &#125;, //错误：普通自定义方法不能放在methods对象中 customFunction () &#123; return 'sth.'; &#125; &#125;;&#125;// 正确示例import wepy from 'wepy';export default class MyComponent extends wepy.component &#123; methods = &#123; bindtap () &#123; let rst = this.commonFunc(); // doSomething &#125;, bindinput () &#123; let rst = this.commonFunc(); // doSomething &#125;, &#125; //正确：普通自定义方法在methods对象外声明，与methods平级 customFunction () &#123; return 'sth.'; &#125;&#125; API文档：https://tencent.github.io/wepy/document.html#/","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://vcodes.me/tags/微信小程序/"}]},{"title":"Gulp自动化构建工具","slug":"gulp自动化构建工具","date":"2017-06-07T03:20:56.000Z","updated":"2018-12-21T03:14:06.389Z","comments":true,"path":"2017/06/07/gulp自动化构建工具/","link":"","permalink":"http://vcodes.me/2017/06/07/gulp自动化构建工具/","excerpt":"Gulp.js 是基于 Node.js 构建的,利用 Node.js 流的威力,可以快速构建项目， 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。","text":"Gulp.js 是基于 Node.js 构建的,利用 Node.js 流的威力,可以快速构建项目， 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。 Gulp安装1234$ sudo npm install -g gulp // 全局安装gulp$ gulp -v // 查看gulp版本号，是否安装成功$ npm init // 创建文件夹，初始化npm(项目名称不能为gulp)$ npm install gulp —save-dev // 当前文件夹安装本地gulp文件 上述命令执行完成后需要再创建一个gulpfile.js文件来用来配置gulp。 Gulp使用我使用gulp最常用的功能就是压缩css,js代码和添加css代码中兼容浏览器前缀。这三个功能分别需要安装三个gulp插件：gulp-uglify（压缩js代码）、gulp-css（压缩css代码）、gulp-autoprefixer（css兼容浏览器前缀）。所以需要通过npm来安装这三个插件： 123$npm install gulp-uglify --save-dev$npm install gulp-css --save-dev$npm install gulp-autoprefixer --save-dev 在项目中我们需要存放我们需要压缩的代码，在项目中创建一个src文件夹，其中存放js，css文件。 ​ |——src ​ |——-js ​ ——main.js ​ |——-css ​ ——main.css ​ 同理我们还需要创建一个压缩代码后存放文件的文件夹。 ​ |——–dist ​ |—— js ​ |——-css ​ 下面就要配置gulp文件了，在刚刚创建的gulpfile.js文件中进行配置。所有配置代码如下： 123456789101112131415161718192021222324252627var gulp = require('gulp');var uglify = require('gulp-uglify');var autoprefixer = require('gulp-autoprefixer');var cssMin = require('gulp-css');gulp.task('script',function()&#123; // 压缩js代码 return gulp.src('src/js/**/*.js') .pipe(uglify()) //引用插件 .pipe(gulp.dest('./dist/js')); //存放的位置&#125;);gulp.task('css',function()&#123; return gulp.src('src/css/**/*.css') .pipe(autoprefixer(&#123; //兼容性浏览器前缀添加 browsers:['last 40 versions'],//版本范围 cascade:false //是否美化属性值 默认是true 这里写false不需要 &#125;)) .pipe(cssMin()) //引用插件 .pipe(gulp.dest('./dist/css'));//存放的位置&#125;);gulp.task('default',['script','css'],function()&#123; console.log('任务完成');&#125;)//如果不需要兼容性前缀添加，直接将pipe(autoprefixer)任务这部分删除。其他同理。 ​ 配置好gulp后就可以将代码存放在src中，通过命令来进行相应操作： 1$ gulp //默认全部执行 1$ gulp script //仅压缩js代码 1$ gulp css //仅压缩css代码","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://vcodes.me/tags/工具/"},{"name":"gulp","slug":"gulp","permalink":"http://vcodes.me/tags/gulp/"}]},{"title":"Git入门","slug":"Git入门","date":"2017-06-05T07:59:19.000Z","updated":"2018-12-21T03:25:20.952Z","comments":true,"path":"2017/06/05/Git入门/","link":"","permalink":"http://vcodes.me/2017/06/05/Git入门/","excerpt":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。","text":"Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git三个状态在Git中存在三个状态：工作区、暂存区、版本状态仓库。 工作区：工作区是我们在本地我们可以看得到的那一部分内容。例如在本地创建的文件夹里的文件，如果修改了文件中的内容可以通过 git status来查看是否文件有修改。 暂存区：当我们想要上传代码到git中首先要将工作区中的文件通过命令上传至git中的暂存区： 1$ git add . //add后面的.是将所有未最终的文件添加在缓存区中。.也可以使用-A代替，实现效果一样。 版本管理仓库：当我们的代码上传到指定服务器中后也，git版本状态中会自动存留一条此次上传文件的版本状态。通过命令可查询： 1$ git log 其中commit是版本识别标识，我们可以通过commit码来回滚到指定版本，命令如下： 1$ git reset --hard 80919da**** //commit码只需要输入前几位即可 git会自动识别 通过Git将文件提交至Github如果文件是第一次提交至github需要将需要上传的文件通过命令git初始化，命令如下: 1$ git init 工作区提交到暂存区： 1$ git add . 将本次提交生成一个标识来帮助我们查看： 1$ git commit -m”someText” 与github建立连接 12git remote add origin git@github.com：yourName / songProject.git //可在github创建一个库复制其git地址 提交文件至github 1git push -u origin master 更新文件更新文件基本与以上操作基本相似： 123$ git add.$ git commit -m&quot;someText&quot;$ git push 注意如果是第一次使用git需要设置用户信息： 12$ git config user.name &quot;username&quot;$ git config user.email &quot;user@email.com&quot; 查看是否设置成功： 12$ git config user.name $ git config user.email","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://vcodes.me/tags/工具/"},{"name":"Git","slug":"Git","permalink":"http://vcodes.me/tags/Git/"}]},{"title":"JavaScript闭包","slug":"JavaScript闭包","date":"2017-04-12T05:29:50.000Z","updated":"2018-12-21T03:14:50.306Z","comments":true,"path":"2017/04/12/JavaScript闭包/","link":"","permalink":"http://vcodes.me/2017/04/12/JavaScript闭包/","excerpt":"闭包算是JavaScript经常会碰到的问题。简单的说就是函数嵌套关系到作用域链的问题。","text":"闭包算是JavaScript经常会碰到的问题。简单的说就是函数嵌套关系到作用域链的问题。 学习了一下阮一峰大神的闭包讲解，概括起来就是变量作用域，全局和局部变量的判断。 123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。所以在闭包中内存中会一直保存着局部变量。会占用内存，内存消耗大，对整体性能有影响。 eg：绑定每个span的click事件，让鼠标点击span的时候alert出对应的index 123456var spans = $(\"#divTest span\"); for (var i = 0; i &lt; spans.length; i++) &#123; spans[i].onclick = function() &#123; alert(i); &#125; &#125; 很简单的功能可是却偏偏出错了，每次alert出的值都是4，所以然者何？ 上面代码在页面加载后就会执行，当i的值为4的时候，判断条件不成立，for循环执行完毕，但是因为每个span的onclick方法这时候为内部函数，所以i被闭包引用，内存不能被销毁，i的值会一直保持4，直到程序改变它或者所有的onclick函数销毁（主动把函数赋为null或者页面卸载）时才会被回收。 这样每次我们点击span的时候，onclick函数会查找i的值（作用域链是引用方式），一查等于4，然后就alert给我们了。而第二种方式是使用了一个立即执行的函数又创建了一层闭包，函数声明放在括号内就变成了表达式，后面再加上括号就是调用了，这时候把i当参数传入，函数立即执行，num保存每次i的值。 12345678910var spans2 = $(\"#divTest2 span\"); $(document).ready(function() &#123; for (var i = 0; i &lt; spans2.length; i++) &#123; (function(num) &#123; spans2[i].onclick = function() &#123; alert(num); &#125; &#125;)(i); &#125; &#125;); 逃脱JavaScript允许像传递任何类型的数据一样传递函数，也就是说JavaScript中的内部函数能够逃脱定义他们的外部函数。 全局变量1234567891011var globalVar;function outerFn() &#123; console.log(\"Outer function\"); function innerFn() &#123; console.log(\"Inner function\"); &#125; globalVar = innerFn;&#125;outerFn();globalVar(); 调用outerFn时会修改全局变量globalVar，这时候它的引用变为innerFn，此后调用globalVar和调用innerFn一样。这时在outerFn外部直接调用innerFn仍然会导致错误，这是因为内部函数虽然通过把引用保存在全局变量中实现了逃脱，但这个函数的名字依然只存在于outerFn的作用域中。 返回值可以通过在父函数的返回值来获得内部函数引用 123456789function outerFn() &#123; console.log(\"Outer function\"); function innerFn() &#123; console.log(\"Inner function\"); &#125; return innerFn;&#125;var fnRef = outerFn();fnRef(); 这里并没有在outerFn内部修改全局变量，而是从outerFn中返回了一个对innerFn的引用。通过调用outerFn能够获得这个引用，而且这个引用可以可以保存在变量中。 闭包的优缺点使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://vcodes.me/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"http://vcodes.me/tags/前端/"}]}]}